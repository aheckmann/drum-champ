<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Drum Champ</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }

        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            background: url('bg.jpeg') no-repeat center center fixed;
            background-size: cover;
            color: #333;
            text-align: center;
        }

        #game-container {
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px 25px 5px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            width: 90%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #controls {
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            width: 100%;
        }

        h1 {
            color: #3f51b5;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.8em;
        }

        :root {
            --num-facets: 12;
            --facet-height: 50px;
            --cylinder-length: 384px;
            --angle: calc(360deg / var(--num-facets));
            --radius: calc((var(--facet-height) / 2) / tan(calc(var(--angle) / 2)));
        }

        .slot-machine-container {
            overflow: hidden;
            border-radius: 10px;
            background: linear-gradient(180deg, #333, #111);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3),
                inset 0 2px 5px rgba(255, 255, 255, 0.3);
            border: 2px solid #444;
            margin-top: 10px;
        }

        .cylinder {
            perspective: 500px;
            width: 400px;
            height: 140px;
            margin: 10px 58px;
        }

        .slot-machine-window {
            transform-style: preserve-3d;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.3);
        }

        .slot-machine-roll {
            position: relative;
            width: var(--cylinder-length);
            height: var(--facet-height);
            transform-style: preserve-3d;
            transform: rotateX(-30deg);
        }

        .pattern-display {
            position: absolute;
            top: calc(50% - (var(--facet-height) / 2));
            left: 0;
            width: var(--cylinder-length);
            height: var(--facet-height);
            background: linear-gradient(to bottom, #ccc, #eee, #ccc);
            display: flex;
            font-family: 'Courier New', Courier, monospace;
            align-items: center;
            font-size: 0.9em;
            color: #555;
            background-color: #fff;
            text-align: center;
            box-sizing: border-box;
            backface-visibility: hidden;
            letter-spacing: 2px;
            justify-content: center;
            word-wrap: break-word;
            transform-style: preserve-3d;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            word-wrap: break-word;
            white-space: pre;
        }

        @keyframes spinVertical {
            from {
                transform: rotateX(0deg);
            }

            to {
                transform: rotateX(360deg);
            }
        }

        #previous-pattern {
            transform: rotateX(calc(var(--angle) * 2)) translateZ(var(--radius));
            opacity: 0.9;
        }

        #sticking-pattern {
            font-size: 1.6em;
            color: #333;
            transform: rotateX(calc(var(--angle) * 1)) translateZ(var(--radius));
            font-weight: bold;
        }

        #upcoming-rudiment,
        #previous-pattern {
            font-size: 1.3em;
            color: #888;
        }

        #upcoming-rudiment {
            transform: rotateX(calc(var(--angle) * 0)) translateZ(var(--radius));
            opacity: 0.6;
        }

        .next-letter {
            display: inline-block;
            background-color: yellow;
            color: #333;
            padding: 0 4px;
            border-radius: 3px;
            box-shadow: 0 0 8px rgba(255, 255, 0, 0.6);
            font-weight: bold;
            animation: pulse 1.5s infinite;
            position: relative;
            z-index: 2;
        }

        #drum-pads {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 20px;
            margin-top: 20px;
            min-height: 110px;
        }

        .pad {
            width: 40%;
            max-width: 120px;
            aspect-ratio: 1 / 1;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.1em;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: transform 0.1s ease, box-shadow 0.1s ease, background-color 0.2s ease;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }

        .pad span {
            font-size: 0.8em;
            font-weight: normal;
            margin-top: 5px;
        }

        #left-pad {
            background-color: #4CAF50;
            border: 4px solid #388E3C;
        }

        #right-pad {
            background-color: #2196F3;
            border: 4px solid #1976D2;
        }

        .pad.active {
            transform: scale(1.1);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.3);
        }

        .pad.highlight {
            border: 4px solid yellow;
            box-shadow: 0 0 15px yellow;
        }

        .pad.correct {
            background-color: #81C784 !important;
            border-color: #66BB6A;
        }

        .pad.incorrect {
            background-color: #E57373 !important;
            border-color: #EF5350;
            animation: shake 0.3s;
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }
        }

        #feedback {
            font-size: 1.1em;
            font-weight: bold;
            min-height: 30px;
            margin-top: 15px;
        }

        #current-input {
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.2em;
            min-height: 25px;
            margin-top: 8px;
            color: #333;
            letter-spacing: 2px;
            background-color: #eee;
            padding: 5px 10px;
            border-radius: 5px;
            display: inline-block;
            word-wrap: break-word;
        }

        button#demo-button {
            display: none;
        }

        .pad.disabled {
            opacity: 0.6;
            cursor: not-allowed;
            pointer-events: none;
            box-shadow: none;
        }

        .next-letter {
            display: inline-block;
            background-color: yellow;
            color: #333;
            padding: 0 4px;
            border-radius: 3px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            font-weight: bold;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }

        /* Add styling for the reset record button */
        #reset-record {
            margin-top: 15px;
            font-size: 0.8em;
            padding: 5px 10px;
            background-color: #607d8b;
            /* Blue Grey */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        #reset-record:hover {
            opacity: 1;
        }

        @keyframes fadeIn {
            from {
                opacity: 0.4;
            }

            to {
                opacity: 1;
            }
        }

        @media (max-width: 670px) {
            .cylinder {
                margin: 10px 0;
                width: 100%;
            }

            .slot-machine-window {
                width: 100%;
            }

            .slot-machine-roll {
                width: 100%;
            }

            .pattern-display {
                width: 100%;
            }
        }

        @media (min-width: 381px) and (max-width: 670px) {

            #previous-pattern,
            #upcoming-rudiment {
                font-size: 0.8em;
            }

            #sticking-pattern {
                font-size: 0.9em;
            }
        }

        @media (max-width: 380px) {

            #previous-pattern,
            #upcoming-rudiment {
                font-size: 0.4em;
            }

            #sticking-pattern {
                font-size: 0.5em;
            }
        }
    </style>
</head>

<body>
    <div id="game-container">
        <h1>Drum Champ</h1>

        <div id="controls">
            <div id="instructions">
                Tap the pads or use keys: <strong>'K'</strong> for Right (R) and <strong>'D'</strong> for Left (L). <br>
                Complete all patterns the fastest to set the record!
            </div>

            <!-- Slot machine container for both patterns -->
            <div class="slot-machine-container">
                <div class="cylinder">
                    <div class="slot-machine-window">
                        <div class="slot-machine-roll">
                            <div id="upcoming-rudiment" class="pattern-display">Next pattern</div>
                            <div id="sticking-pattern" class="pattern-display"></div>
                            <div id="previous-pattern" class="pattern-display"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="drum-pads">
                <div class="pad" id="left-pad">L<span>(D key)</span></div>
                <div class="pad" id="right-pad">R<span>(K key)</span></div>
            </div>
        </div>
        <div id="feedback">Tap Pad or Press Key to start...</div>

        <button id="reset-record">Reset Record</button>
    </div>

    <script>
        const rudiments = [
            { pattern: "RLRLRLRL", sound: "samples/crash-1.mp3" },
            { pattern: "LRLRLRLR", sound: "samples/crash-2.mp3" },
            { pattern: "RRLLRRLL", sound: "samples/crash-2.mp3" },
            { pattern: "LLRRLLRR", sound: "samples/crash-3.mp3" },
            { pattern: "RLRRLRLL", sound: "samples/crash-4.mp3" },
            { pattern: "LRRLRLLR", sound: "samples/crash-3.mp3" },
            { pattern: "RRLRLLRL", sound: "samples/crash-4.mp3" },
            { pattern: "RLRLLRLR", sound: "samples/crash-5.mp3" },
            { pattern: "LRLLRLRR", sound: "samples/crash-4.mp3" },
            { pattern: "RLLRLRRL", sound: "samples/crash-5.mp3" },
            { pattern: "LLRLRRLR", sound: "samples/crash-6.mp3" },
            { pattern: "LRLRRLRL", sound: "samples/crash-7.mp3" },
        ];
        for (const rud of rudiments) {
            rud.pattern = `${rud.pattern}${rud.pattern}`;
        }
        const preloadSounds = [
            "samples/fail.mp3",
            "samples/wilhelm_scream.mp3",
            "samples/cheer.mp3",
        ]

        let currentRudimentIndex = 0;
        let currentPattern = '';
        let expectedInput = '';
        let playerInput = '';
        let correctRepetitions = 0;
        let requiredRepetitions = 3;
        let audioContext;
        let rightSoundBuffer;
        let soundInitialized = false;
        let soundBufferCache = {}; // Cache for storing loaded sound buffers
        let fillSoundBuffer; // For the fill sound at game completion
        let beatSoundBuffer; // For the looping beat sound
        let beatLoopSource; // To track the looping beat sound source

        // --- DOM Elements ---
        const stickingPatternEl = document.getElementById('sticking-pattern');
        const instructionsEl = document.getElementById('instructions');
        const repetitionsNeededEl = document.getElementById('repetitions-needed');
        const leftPadEl = document.getElementById('left-pad');
        const rightPadEl = document.getElementById('right-pad');
        const feedbackEl = document.getElementById('feedback');
        const currentPatternEl = document.getElementById('current-pattern');

        // Add missing global variables
        let startTime = null;
        let timerInterval = null;
        let timerEl, highScoreEl;

        // --- Audio Setup ---
        function initAudio() {
            if (soundInitialized) return; // Prevent re-initialization
            soundInitialized = true;
            try {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!window.AudioContext) {
                    console.warn("Web Audio API is not supported in this browser.");
                    feedbackEl.textContent = "Warning: Audio not supported.";
                    feedbackEl.style.color = 'orange';
                    return;
                }
                audioContext = new AudioContext();
                // Resume context on first user interaction (required by browsers)
                const resumeAudio = (e) => {
                    switch (audioContext.state) {
                        case 'suspended': {
                            audioContext.resume();
                        }
                    }
                };
                document.addEventListener('click', resumeAudio);
                document.addEventListener('keydown', resumeAudio);
                document.addEventListener('touchstart', resumeAudio);

                loadSound('samples/snare.mp3').then(buffer => rightSoundBuffer = buffer).catch(e => console.error("Error loading snare sound:", e));
                loadSound('samples/fill.mp3').then(buffer => fillSoundBuffer = buffer).catch(e => console.error("Error loading fill sound:", e));
                loadSound('samples/beat.mp3').then(buffer => beatSoundBuffer = buffer).catch(e => console.error("Error loading beat sound:", e));
                for (const rud of rudiments) {
                    loadSound(rud.sound).catch(e => console.error("Error loading sound:", e));
                }
                for (const sound of preloadSounds) {
                    loadSound(sound).catch(e => console.error("Error loading sound:", e));
                }

                console.log("Audio initialized.");
            } catch (e) {
                console.error("Error initializing AudioContext:", e);
                feedbackEl.textContent = "Error initializing audio.";
                feedbackEl.style.color = 'red';
            }
        }

        async function loadSound(url) {
            if (!audioContext) return null;

            // Check if the sound is already in the cache
            if (soundBufferCache[url]) {
                return soundBufferCache[url];
            }

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for ${url}`);
                }
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                console.log(`Sound loaded: ${url}`);

                // Store the sound in the cache
                soundBufferCache[url] = audioBuffer;

                return audioBuffer;
            } catch (error) {
                console.error(`Could not load sound file: ${url}`, error);
                feedbackEl.textContent = `Error loading ${url.split('/').pop()}. Check console.`;
                feedbackEl.style.color = 'red';
                return null; // Indicate failure
            }
        }

        function playSound(buffer) {
            // Attempt to resume if suspended, might happen if interaction was missed
            console.log('audioContext.state', audioContext?.state);
            if (audioContext?.state === 'suspended') {
                audioContext.resume();
            }

            if (!audioContext || !buffer || audioContext.state !== 'running') {
                // Don't play if context not running or buffer invalid
                return;
            }
            try {
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.playbackRate.value = 1 - (Math.random() * 0.06);

                source.connect(audioContext.destination);
                source.start(0); // Play immediately
            } catch (error) {
                console.error("Error playing sound:", error);
            }
        }

        // Function to play completion sound based on rudiment sound property
        async function playCompleteSound(soundFile) {
            if (!soundFile) {
                return;
            }

            // Load and play the specific sound for this rudiment
            try {
                const buffer = await loadSound(soundFile);
                if (buffer) {
                    playSound(buffer);
                } else {
                    // Fallback to default crash sound if loading fails
                    console.warn(`Failed to load ${soundFile}`);
                }
            } catch (error) {
                console.error("Error playing rudiment sound:", error);
            }
        }

        // Function to play the fill sound when game completes
        function playFillSound(onComplete) {
            if (!audioContext || !fillSoundBuffer || audioContext.state !== 'running') {
                if (onComplete) onComplete(); // Call completion callback immediately if we can't play
                return;
            }

            try {
                const source = audioContext.createBufferSource();
                source.buffer = fillSoundBuffer;
                source.connect(audioContext.destination);

                if (onComplete) {
                    source.onended = onComplete; // Execute callback when sound finishes
                }

                source.start(0); // Play immediately
            } catch (error) {
                console.error("Error playing fill sound:", error);
                if (onComplete) onComplete(); // Ensure callback runs even if error
            }
        }

        // Function to play beat in a loop
        function playBeatLoop() {
            if (!audioContext || !beatSoundBuffer || audioContext.state !== 'running') {
                return;
            }

            try {
                stopBeatLoop();

                beatLoopSource = audioContext.createBufferSource();
                beatLoopSource.buffer = beatSoundBuffer;
                beatLoopSource.loop = true; // Enable looping
                beatLoopSource.connect(audioContext.destination);
                beatLoopSource.start(0); // Play immediately
            } catch (error) {
                console.error("Error playing beat loop:", error);
            }
        }

        // Function to stop the beat loop
        function stopBeatLoop() {
            if (beatLoopSource) {
                try {
                    beatLoopSource.stop();
                } catch (e) {
                    console.error("Error stopping beat loop:", e);
                }
                beatLoopSource = null;
            }
        }

        // Function to play fail sound with probability distribution
        async function playFailSound() {
            // 85% chance for regular fail sound, 15% chance for wilhelm scream
            const randomValue = Math.random();
            const soundFile = (randomValue < 0.85) ? 'samples/fail.mp3' : 'samples/wilhelm_scream.mp3';

            try {
                const buffer = await loadSound(soundFile);
                if (buffer) {
                    playSound(buffer);
                }
            } catch (error) {
                console.error(`Error playing fail sound: ${soundFile}`, error);
            }
        }

        // Function to play cheer sound when game completes
        async function playCheerSound() {
            try {
                const buffer = await loadSound('samples/cheer.mp3');
                if (buffer) {
                    playSound(buffer);
                }
            } catch (error) {
                console.error("Error playing cheer sound:", error);
            }
        }

        // --- Game Logic ---
        function formatSticking(pattern) {
            // Always use consistent groups of four letters
            const chunkSize = 4;
            let formatted = '';
            for (let i = 0; i < pattern.length; i += chunkSize) {
                formatted += pattern.substring(i, i + chunkSize) + ' ';
            }
            return formatted.trim();
        }

        function updateRudiments(index) {
            const prevRudiment = rudiments[index - 1] || null;
            const nextRudiment = rudiments[index + 1] || null;
            const upcomingRudimentEl = document.getElementById('upcoming-rudiment');
            const previousRudimentEl = document.getElementById('previous-pattern');

            if (prevRudiment) {
                previousRudimentEl.textContent = formatSticking(prevRudiment.pattern);
            } else {
                previousRudimentEl.textContent = '';
            }

            if (nextRudiment) {
                upcomingRudimentEl.textContent = formatSticking(nextRudiment.pattern);
            } else {
                upcomingRudimentEl.textContent = 'Final Pattern!';
                upcomingRudimentEl.style.color = '#999';
            }
        }

        function animatePatternChange() {
            const roll = document.querySelector('.slot-machine-roll');

            // Add animation class with CSS transformation to move patterns upward
            roll.style.transition = 'transform 0.1s ease-in-out';
            roll.style.transform = 'rotateX(' + (360 / 12) + 'deg)'; // Rotate one facet angle

            // After animation completes, reset position and update pattern elements
            setTimeout(() => {
                // Remove transition to instantly reset position
                roll.style.transition = 'none';
                roll.style.transform = 'rotateX(-30deg)'; // Reset to original position

                // After reset is complete (after a tiny delay)
                setTimeout(() => {
                    // Re-enable transitions for future animations
                    roll.style.transition = 'transform 0.2s ease-in-out';
                }, 50);
            }, 100); // Same duration as the transition
        }

        function loadRudiment(index) {
            const previousRudiment = rudiments[index - 1] || null;
            const currentRudiment = rudiments[index];
            const nextRudiment = rudiments[index + 1] || null;

            if (!currentRudiment) {
                completeGame(); // End game when no more rudiments
                return;
            }

            // Add animation when changing patterns
            if (index > 0) {
                animatePatternChange();
            }

            currentRudimentIndex = index;
            currentPattern = currentRudiment.pattern;
            expectedInput = currentPattern;
            requiredRepetitions = 1;
            correctRepetitions = 0;
            playerInput = '';

            updateStickingDisplay();
            updateRudiments(index);

            if (repetitionsNeededEl) {
                repetitionsNeededEl.textContent = requiredRepetitions;
            }

            feedbackEl.textContent = 'Tap Pad or Press Key to start...';
            feedbackEl.style.color = '#555'; // Reset feedback color
            resetPadStyles();

            // Ensure pads are visible if hidden previously
            if (document.getElementById('drum-pads').style.display === 'none') {
                document.getElementById('drum-pads').style.display = 'flex';
                addInputListeners(); // Re-add listeners if game was completed before
            }
        }

        function resetPadStyles(pad = null) {
            const pads = pad ? [pad] : [leftPadEl, rightPadEl];
            pads.forEach(p => {
                p.classList.remove('active', 'correct', 'incorrect', 'highlight');
                // Restore original background color based on ID
                if (p.id === 'left-pad') p.style.backgroundColor = '#4CAF50'; // Green
                if (p.id === 'right-pad') p.style.backgroundColor = '#2196F3'; // Blue
            });
        }

        function flashPad(key, styleClass = 'active', duration = 150) {
            const pad = (key === 'd') ? leftPadEl : rightPadEl;
            if (pad) {
                resetPadStyles(pad); // Reset specific pad first
                pad.classList.add(styleClass);
                setTimeout(() => {
                    // Only remove the specific class, keep correct/incorrect background
                    pad.classList.remove(styleClass);
                    if (styleClass !== 'correct' && styleClass !== 'incorrect') {
                        resetPadStyles(pad); // Fully reset if just active/highlight
                    }
                }, duration);
            }
        }

        function highlightPad(key, duration = 500) {
            const pad = (key === 'd') ? leftPadEl : rightPadEl;
            if (pad) {
                pad.classList.add('highlight');
                setTimeout(() => pad.classList.remove('highlight'), duration - 50);
            }
        }

        function processInput(key) {
            initAudio(); // Ensure audio is ready on first interaction

            if (key !== 'd' && key !== 'k') {
                return; // Ignore input if not D/K (removed demo check)
            }

            if (!startTime) {
                startTimer(); // Start the timer when the player begins playing
            }

            if (playerInput.length >= expectedInput.length) {
                return; // Sequence already complete for this rep
            }

            const expectedNote = expectedInput[playerInput.length]; // 'R' or 'L'
            const expectedKey = (expectedNote === 'L') ? 'd' : 'k';
            const hand = (key === 'd') ? 'L' : 'R';
            const snareBuffer = soundBufferCache['samples/snare.mp3'];

            if (key === expectedKey) {
                playSound(snareBuffer);
                playerInput += hand;
                feedbackEl.textContent = 'Correct!';
                feedbackEl.style.color = 'green';
                flashPad(key, 'correct', 200);

                // Update the sticking pattern display to highlight next note
                updateStickingDisplay();

                if (playerInput.length === expectedInput.length) {
                    correctRepetitions++;
                    playerInput = '';

                    if (correctRepetitions >= requiredRepetitions) {
                        feedbackEl.textContent = `Level Complete! Next pattern loaded.`;
                        feedbackEl.style.color = '#3f51b5'; // Indigo

                        // Play the rudiment-specific completion sound
                        const currentRudiment = rudiments[currentRudimentIndex];
                        playCompleteSound(currentRudiment.sound);

                        loadRudiment(currentRudimentIndex + 1); // Load next pattern immediately
                    } else {
                        const remaining = requiredRepetitions - correctRepetitions;
                        feedbackEl.textContent = `Nice! ${remaining} more time${remaining > 1 ? 's' : ''}.`;
                        feedbackEl.style.color = 'green';
                    }
                }
            } else {
                // Incorrect input - play fail sound
                playFailSound();

                feedbackEl.textContent = `Wrong! Expected ${expectedNote} (${expectedKey.toUpperCase()}). Resetting sequence.`;
                feedbackEl.style.color = 'red';
                flashPad(key, 'incorrect', 300); // Flash the pad they hit red
                playerInput = ''; // Reset current input
                correctRepetitions = 0; // Reset progress on error
                updateStickingDisplay(); // Also update after error
            }
        }

        function updateStickingDisplay() {
            // Format and display sticking pattern with next note highlighted
            const fullPattern = formatSticking(currentPattern, requiredRepetitions);
            let displayHtml = '';

            // Find which position in the pattern the player is at
            const positionInPattern = playerInput.length % currentPattern.length;

            // Track both actual character position and pattern position
            let charCount = 0;
            let letterCount = 0;
            let highlightApplied = false;

            // Build HTML with highlighting
            for (let i = 0; i < fullPattern.length; i++) {
                const char = fullPattern[i];

                // Skip spaces when counting meaningful positions
                if (char === ' ') {
                    displayHtml += char;
                    continue;
                }

                // Only apply highlight to the first matching position
                if (!highlightApplied && letterCount === positionInPattern && (char === 'R' || char === 'L')) {
                    displayHtml += `<span class="next-letter">${char}</span>`;
                    highlightApplied = true;
                } else {
                    displayHtml += char;
                }

                // Only increment letter count for actual R and L characters
                if (char === 'R' || char === 'L') {
                    letterCount = (letterCount + 1) % currentPattern.length;
                }
            }

            stickingPatternEl.innerHTML = displayHtml;
        }

        // --- Event Listener Setup ---
        function handleKeyPress(event) {
            const key = event.key.toLowerCase();
            processInput(key);
        }

        function handlePadTap(event) {
            event.preventDefault(); // Prevent default touch behavior (like scrolling or zoom)
            const padId = event.currentTarget.id; // Use currentTarget to ensure it's the element listener was attached to
            const key = (padId === 'left-pad') ? 'd' : 'k';
            processInput(key);
        }

        function addInputListeners() {
            document.addEventListener('keydown', handleKeyPress);
            leftPadEl.addEventListener('touchstart', handlePadTap, { passive: false }); // Use touchstart for mobile responsiveness
            rightPadEl.addEventListener('touchstart', handlePadTap, { passive: false });
            leftPadEl.addEventListener('mousedown', handlePadTap); // mousedown often feels faster than click
            rightPadEl.addEventListener('mousedown', handlePadTap);
        }

        function removeInputListeners() {
            document.removeEventListener('keydown', handleKeyPress);
            leftPadEl.removeEventListener('touchstart', handlePadTap);
            rightPadEl.removeEventListener('touchstart', handlePadTap);
            leftPadEl.removeEventListener('mousedown', handlePadTap);
            rightPadEl.removeEventListener('mousedown', handlePadTap);
        }

        function startTimer() {
            startTime = performance.now();
            timerInterval = setInterval(updateTimerDisplay, 100);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function getElapsedTime() {
            if (!startTime) return 0;
            return performance.now() - startTime;
        }

        function updateTimerDisplay() {
            const elapsedTime = getElapsedTime();
            if (!timerEl) {
                timerEl = document.getElementById('timer');
            }
            if (timerEl) {
                timerEl.textContent = `Time: ${(elapsedTime / 1000).toFixed(3)}s`;
            }
        }

        function setCookie(name, value, days) {
            const date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            document.cookie = `${name}=${value};expires=${date.toUTCString()};path=/`;
        }

        function getCookie(name) {
            const cookies = document.cookie.split(';');
            for (let cookie of cookies) {
                const [key, value] = cookie.trim().split('=');
                if (key === name) return value;
            }
            return null;
        }

        function loadHighScore() {
            const highScore = getCookie('highScore');
            return highScore ? parseFloat(highScore) : null;
        }

        function saveHighScore(time) {
            const highScore = loadHighScore();
            if (highScore === null || time < highScore) {
                setCookie('highScore', time, 180); // Save for 6 months
                return time;
            }
            return highScore;
        }

        function displayHighScore() {
            const highScore = loadHighScore();
            if (!highScoreEl) {
                highScoreEl = document.getElementById('high-score');
            }
            if (highScoreEl) {
                highScoreEl.textContent = highScore ? `Record: ${(highScore / 1000).toFixed(3)}s` : '';
            }
            if (highScore) {
                document.getElementById('reset-record').style.display = 'block';
            } else {
                document.getElementById('reset-record').style.display = 'none';
            }
        }

        function completeGame() {
            stopTimer();
            const elapsedTime = getElapsedTime();
            const highScore = saveHighScore(elapsedTime);

            // Hide the controls when game ends
            document.getElementById('controls').style.display = 'none';

            // Play cheer sound immediately
            playCheerSound();

            // Play fill sound, then start beat loop when it completes
            playFillSound(() => {
                playBeatLoop();
            });

            feedbackEl.innerHTML = `Game Complete!<br>Time: ${(elapsedTime / 1000).toFixed(3)}s.<br>Record: ${(highScore / 1000).toFixed(3)}s`;
            feedbackEl.style.color = '#3f51b5'; // Indigo

            // Check if Play Again button already exists
            let playAgainBtn = document.getElementById('play-again-button');
            // Only create a new button if one doesn't exist already
            if (!playAgainBtn) {
                playAgainBtn = document.createElement('button');
                playAgainBtn.id = 'play-again-button';
                playAgainBtn.textContent = 'Play Again';
                playAgainBtn.style.padding = '10px 20px';
                playAgainBtn.style.fontSize = '1em';
                playAgainBtn.style.backgroundColor = '#4CAF50'; // Green
                playAgainBtn.style.color = 'white';
                playAgainBtn.style.border = 'none';
                playAgainBtn.style.borderRadius = '5px';
                playAgainBtn.style.cursor = 'pointer';
                playAgainBtn.style.marginTop = '20px';
                playAgainBtn.addEventListener('click', resetGame);
                document.getElementById('game-container').appendChild(playAgainBtn);
            } else {
                // If button already exists, make sure it's visible
                playAgainBtn.style.display = 'inline-block';
            }
        }

        function resetGame() {
            stopBeatLoop();

            const playAgainBtn = document.getElementById('play-again-button');
            if (playAgainBtn) {
                playAgainBtn.remove();
            }

            // Reset game state variables
            currentRudimentIndex = 0;
            startTime = null;
            correctRepetitions = 0;
            playerInput = '';

            displayHighScore();
            document.getElementById('controls').style.display = 'block';
            document.getElementById('timer').innerHTML = 'Time: 0.000s';
            feedbackEl.textContent = 'Tap Pad or Press Key to start...';

            loadRudiment(0);
        }

        function resetHighScore() {
            if (confirm('Are you sure you want to reset your record?')) {
                setCookie('highScore', '', -1); // Set cookie to expire immediately
                displayHighScore();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            timerEl = document.createElement('div');
            timerEl.id = 'timer';
            timerEl.style.marginTop = '10px';
            timerEl.style.fontSize = '1.2em';
            timerEl.style.color = '#333';
            timerEl.textContent = 'Time: 0.000s';
            document.getElementById('controls').appendChild(timerEl);

            highScoreEl = document.createElement('div');
            highScoreEl.id = 'high-score';
            highScoreEl.style.marginTop = '5px';
            highScoreEl.style.fontSize = '1em';
            highScoreEl.style.color = '#555';
            document.getElementById('controls').appendChild(highScoreEl);

            displayHighScore();

            document.getElementById('reset-record').addEventListener('click', resetHighScore);
            addInputListeners();
            loadRudiment(0);
        });

        addInputListeners();
        initAudio();
    </script>
</body>

</html>
